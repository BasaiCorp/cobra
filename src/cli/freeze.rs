use crate::{Result, CobraError};
use crate::core::{config::CobraConfig, package_manager::LocalPackageManager};
use colored::Colorize;
use std::path::Path;
use std::sync::Arc;
use tokio::fs;

pub async fn execute(output_file: Option<String>) -> Result<()> {
    let config_path = Path::new("cobra.toml");
    if !config_path.exists() {
        return Err(CobraError::Config(
            "No cobra.toml found. Run 'cobra init' to create one.".to_string()
        ));
    }

    let config = CobraConfig::load(config_path).await?;
    
    // Initialize package manager
    let install_dir = std::env::current_dir()?.join(config.get_install_dir());
    let package_manager = Arc::new(LocalPackageManager::new(install_dir));
    
    // Get installed packages
    let installed_packages = package_manager.list_installed().await?;
    
    if installed_packages.is_empty() {
        println!("No packages installed.");
        return Ok(());
    }
    
    // Generate requirements content
    let mut requirements_content = String::new();
    requirements_content.push_str("# Generated by Cobra Package Manager\n");
    requirements_content.push_str(&format!("# Frozen on {}\n", chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC")));
    requirements_content.push_str("\n");
    
    // Sort packages alphabetically for consistent output
    let mut sorted_packages = installed_packages;
    sorted_packages.sort_by(|a, b| a.name.cmp(&b.name));
    
    for package in &sorted_packages {
        requirements_content.push_str(&format!("{}=={}\n", package.name, package.version));
    }
    
    // Output to file or stdout
    match output_file {
        Some(file_path) => {
            fs::write(&file_path, &requirements_content).await?;
            println!("Requirements frozen to {}", file_path.cyan());
            println!("Total: {} packages", sorted_packages.len().to_string().bold());
        }
        None => {
            // Output to stdout
            print!("{}", requirements_content);
        }
    }
    
    Ok(())
}

pub async fn execute_with_format(
    output_file: Option<String>, 
    format: Option<String>
) -> Result<()> {
    let format = format.unwrap_or_else(|| "pip".to_string());
    
    match format.as_str() {
        "pip" => execute(output_file).await,
        "poetry" => execute_poetry_format(output_file).await,
        "pipenv" => execute_pipenv_format(output_file).await,
        _ => Err(CobraError::InvalidInput(
            format!("Unsupported format: {}. Supported formats: pip, poetry, pipenv", format)
        ))
    }
}

async fn execute_poetry_format(output_file: Option<String>) -> Result<()> {
    let config_path = Path::new("cobra.toml");
    if !config_path.exists() {
        return Err(CobraError::Config(
            "No cobra.toml found. Run 'cobra init' to create one.".to_string()
        ));
    }

    let config = CobraConfig::load(config_path).await?;
    let install_dir = std::env::current_dir()?.join(config.get_install_dir());
    let package_manager = Arc::new(LocalPackageManager::new(install_dir));
    let installed_packages = package_manager.list_installed().await?;
    
    if installed_packages.is_empty() {
        println!("No packages installed.");
        return Ok(());
    }
    
    let mut content = String::new();
    content.push_str("[tool.poetry.dependencies]\n");
    content.push_str("python = \"^3.8\"\n");
    
    let mut sorted_packages = installed_packages;
    sorted_packages.sort_by(|a, b| a.name.cmp(&b.name));
    
    for package in &sorted_packages {
        content.push_str(&format!("{} = \"^{}\"\n", package.name, package.version));
    }
    
    match output_file {
        Some(file_path) => {
            fs::write(&file_path, &content).await?;
            println!("Poetry dependencies frozen to {}", file_path.cyan());
        }
        None => {
            print!("{}", content);
        }
    }
    
    Ok(())
}

async fn execute_pipenv_format(output_file: Option<String>) -> Result<()> {
    let config_path = Path::new("cobra.toml");
    if !config_path.exists() {
        return Err(CobraError::Config(
            "No cobra.toml found. Run 'cobra init' to create one.".to_string()
        ));
    }

    let config = CobraConfig::load(config_path).await?;
    let install_dir = std::env::current_dir()?.join(config.get_install_dir());
    let package_manager = Arc::new(LocalPackageManager::new(install_dir));
    let installed_packages = package_manager.list_installed().await?;
    
    if installed_packages.is_empty() {
        println!("No packages installed.");
        return Ok(());
    }
    
    let mut content = String::new();
    content.push_str("[[source]]\n");
    content.push_str("url = \"https://pypi.org/simple\"\n");
    content.push_str("verify_ssl = true\n");
    content.push_str("name = \"pypi\"\n\n");
    content.push_str("[packages]\n");
    
    let mut sorted_packages = installed_packages;
    sorted_packages.sort_by(|a, b| a.name.cmp(&b.name));
    
    for package in &sorted_packages {
        content.push_str(&format!("{} = \"=={}\"\n", package.name, package.version));
    }
    
    content.push_str("\n[dev-packages]\n\n");
    content.push_str("[requires]\n");
    content.push_str("python_version = \"3.8\"\n");
    
    match output_file {
        Some(file_path) => {
            fs::write(&file_path, &content).await?;
            println!("Pipenv dependencies frozen to {}", file_path.cyan());
        }
        None => {
            print!("{}", content);
        }
    }
    
    Ok(())
}
